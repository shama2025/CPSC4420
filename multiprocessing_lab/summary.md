## Multiprocessing Expereince

For this lab, I decided to find a practical application of forks using a sockets in c and multithreading in python. The goal was to simulate a server being pinged by multiple agents and understand at a deeper level how servers can use multiprocessing to handle different clients trying to request information from a backend. While implementing the fork command, I found that it creates that copy of the process in the code following the fork command. Upon cloning the process, the fork command returns a process ID to the parent and a 0 to the child process. With this, we as programmers are able to get more information regarding the process such as using the getpid function, which returns the process ID. To continue my study into the fork command, I looked into the [unistd.h library documentaton](https://pubs.opengroup.org/onlinepubs/7908799/xsh/fork.html) to help further my study into the fork function. This document helped me understand more about what fork returns to the parent and child processes as well as how to avoid certain errors and edge cases when utilizing multiprocessing. During the lab, I ran into a few issues when accepting new requests in the socket. Due to how I was deleting the server's file descriptor and not the newly created socket which caused acceptance errors. Once I integrated multiprocessing, I did have to account for that added complexity and adjust for multiple agents pinging a server. One thing I did not add, was the waitpid function, which stalls a process until the child process changes its state. I didn't add this since I wanted to make sure my server could handle multiple agents simultaneously. Adding waitpid would pause the parent from deleting the current socket and prevent the addition of zombie processes.
